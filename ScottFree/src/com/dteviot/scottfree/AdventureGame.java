/* Automatically generated by Scott2Java */
package com.dteviot.scottfree;

import java.util.Random;

public class AdventureGame {
  /* Game Data */
  final boolean ScottLight = false;
  final boolean Trash80 = false;
  final boolean OldLamp = false;
  final boolean UseYou = false;

  /*
   * Data describing the adventure
   */
  AdventureStaticData mStaticData;

  boolean atCarryLimit() {
    return CountCarried() >= mStaticData.getMaxCarry();
  }

  Room getRoom(int index) {
    return mStaticData.getRooms()[index];
  }

  ;

  int GameCode(int index) {
    return mStaticData.getGameCode()[index];
  }

  static String[] ExitNames = { "North", "South", "East", "West", "Up", "Down" };
  static String[] Quickies = { "N", "S", "E", "W", "U", "D" };

  /* Constants */
  final int Lamp = 9;
  final int DarkFlag = 15;
  final int LightOutFlag = 16;

  public final static int NoWord = 1000;  /* Can't occur in real game */
  public final static int AnyWord = 0;
  final int VerbGo = 1;
  final int VerbGet = 10;
  final int VerbDrop = 18;
  final int DirNorth = 1;
  final int DirDown = 6;

  /* Per game instance */
  boolean[] Flags;
  int[] Counters;
  int[] Yoho;
  int Location;
  int CurCounter;    /* Value not instance */
  int CurYoho;
  int LightTime;
  Item[] Items;

  /* Execution Environment */
  int[] Params;
  int ParamPtr;
  boolean Continuation;
  boolean Ended;
  boolean Redraw;    /* Pending redraw */
  Random Rng;

  /* Parser */
  String NounString;
  int NounCode;
  int VerbCode;

  /* Output Subsystem */
  ScottOutput mDrawingAgent;

  public AdventureGame(ScottOutput output) {
    Params = new int[5];
    mDrawingAgent = output;
  }

  public void setStaticData(AdventureStaticData staticData) {
    mStaticData = staticData;
    reset();
  }

  /*
   * Set game to starting condition
   */
  public void reset() {
    Flags = new boolean[32];
    Counters = new int[16];
    Yoho = new int[16];
    Items = mStaticData.createItems();
    CurCounter = 0;
    LightTime = mStaticData.getLightRefill();
    Redraw = false;
    Ended = false;
    Location = mStaticData.getPlayerStartRoom();
    Rng = new Random();
    mDrawingAgent.reset();
  }

  /*
   * Pack state into a string
   */
  public String serializeState() {
    StringBuilder sb = new StringBuilder();
    for (boolean b : Flags) {
      sb.append(b ? "t" : "f");
    }
    appendArray(sb, Counters);
    appendArray(sb, Yoho);
    appendArray(sb, Items);
    appendInt(sb, CurCounter);
    appendInt(sb, LightTime);
    appendInt(sb, Location);
    return sb.toString();
  }

  private void appendArray(StringBuilder sb, Item[] a) {
    for (Item i : a) {
      appendInt(sb, i.getLocation());
    }
  }

  private void appendArray(StringBuilder sb, int[] a) {
    for (int i : a) {
      appendInt(sb, i);
    }
  }

  private void appendInt(StringBuilder sb, int i) {
    sb.append("," + i);
  }

  /*
   * Restore state from a string
   */
  public void deserializeState(String savedState) {
    String[] values = savedState.split(",");
    // restore flags
    for (int i = 0; i < Flags.length; ++i) {
      Flags[i] = values[0].charAt(i) == 't';
    }
    int index = 1;
    index = deserializeArray(values, index, Counters);
    index = deserializeArray(values, index, Yoho);
    index = deserializeArray(values, index, Items);

    CurCounter = deserializeInt(values, index++);
    LightTime = deserializeInt(values, index++);
    Location = deserializeInt(values, index++);
  }

  private int deserializeArray(String[] values, int startIndex, Item[] array) {
    for (int i = 0; i < array.length; ++i) {
      array[i].setLocation(deserializeInt(values, startIndex + i));
    }
    return startIndex + array.length;
  }

  private int deserializeArray(String[] values, int startIndex, int[] array) {
    for (int i = 0; i < array.length; ++i) {
      array[i] = deserializeInt(values, startIndex + i);
    }
    return startIndex + array.length;
  }

  private int deserializeInt(String[] values, int index) {
    return Integer.parseInt(values[index]);
  }

  /*
   *	Gamecode helpers
   */
  int CountCarried() {
    int count = 0;
    for (Item item : Items) {
			if (item.isInInventory()) {
				count++;
			}
    }
    return count;
  }

  int CountTreasure() {
    int count = 0;
    for (Item item : Items) {
			if (item.isIn(mStaticData.getTreasureRoom()) && item.isTreasure()) {
				count++;
			}
    }
    return count;
  }

  /*
   *	Condition code engine
   */

  /* Remember char is 16bit unsigned, we use this because java is
     a broken pile of donkey poo when it comes to unsigned maths */
  boolean ExecuteCondition(int c) {
    int op = (c % 20);
    int val = (c / 20);


    /* 		System.out.print("C"+(int)op+"P="+(int)val+" "); */
    switch (op) {
      case 0:
        Params[ParamPtr++] = val;
        return true;
      case 1:
        return Items[val].isInInventory();
      case 2:
        return Items[val].isIn(Location);
      case 3:
        return Items[val].isInInventory() || Items[val].isIn(Location);
      case 4:
        return (Location == val);
      case 5:
        return !Items[val].isIn(Location);
      case 6:
        return !Items[val].isInInventory();
      case 7:
        return (Location != val);
      case 8:
        return Flags[val];
      case 9:
        return !Flags[val];
      case 10:
        return (CountCarried() != 0);
      case 11:
        return (CountCarried() == 0);
      case 12:
        return !(Items[val].isInInventory() || Items[val].isIn(Location));
      case 13:
        return !Items[val].isDestroyed();
      case 14:
        return Items[val].isDestroyed();
      case 15:
        return (CurCounter <= val);
      case 16:
        return (CurCounter >= val);
      case 17:
        return Items[val].isAtStartLocation();
      case 18:
        return !Items[val].isAtStartLocation();
      case 19:
        return (CurCounter == val);
    }
    /* Because the compiler is too stupid to work this out */
    return false;
  }

  /* User Interface */
  void Output(String s) {
    mDrawingAgent.outputBottom(s);
  }

  void OutputNumber(int n) {
    mDrawingAgent.outputBottomNumber(n);
  }

  void ClearScreen() {
  }

  void DrawPicture(int p) {
  }

  void TwoSecondDelay() {
  }

  void TopBegin() {
    mDrawingAgent.topBegin();
  }

  void TopOutput(String s) {
    mDrawingAgent.topOutput(s);
  }

  void TopDone() {
  }

  /* Unimplemented I/O hook */
  void SaveGame() {
  }

  /*
   * 	Action Helpers
   */
  int Param() {
    return Params[ParamPtr++];
  }

  void CarryLimit() {
		if (UseYou) {
			Output("You are carrying too much. ");
		} else {
			Output("I've too much to carry! ");
		}
  }

  void GameOver() {
    Output("The game is now over.\n");
    Ended = true;
  }

  void Plonk(int thing, int where) {
		if (Items[thing].isIn(Location) || where == Location) {
			Redraw = true;
		}
    Items[thing].setLocation(where);
  }

  boolean Dark() {
    boolean dark = Flags[DarkFlag];

		if (Items[Lamp].isIn(Location) ||
				Items[Lamp].isInInventory()) {
			dark = false;
		}
    return dark;
  }

  /*
   *	Complex operation blocks
   */
  void Inventory() {
    boolean f = false;
		if (UseYou) {
			Output("You are carrying:\n");
		} else {
			Output("I'm carrying:\n");
		}
    for (Item item : Items) {
      if (item.isInInventory()) {
        if (f == true) {
					if (Trash80 == true) {
						Output(". ");
					} else {
						Output(" - ");
					}
        }
        f = true;
        Output(item.getName());
      }
    }
		if (f == false) {
			Output("Nothing");
		}
    Output(".\n");
  }

  void Look() {
    boolean printed = false;
    TopBegin();
    if (Dark()) {
			if (UseYou == true) {
				TopOutput("You can't see. It is too dark!\n");
			} else {
				TopOutput("I can't see. It is too dark!\n");
			}
      TopDone();
      return;
    }

    String roomDescription = getRoom(Location).getDescription();
		if (roomDescription.charAt(0) == '*') {
			TopOutput(roomDescription.substring(1));
		} else {
			if (UseYou == true) {
				TopOutput("You are ");
			} else {
				TopOutput("I'm in a ");
			}
			TopOutput(roomDescription);
		}
    TopOutput("\nObvious exits: ");

    for (int i = 0; i < Room.EXITS_PER_ROOM; i++) {
      if (getRoom(Location).getExit(i) != 0) {
				if (printed == true) {
					TopOutput(",");
				}
        printed = true;
        TopOutput(ExitNames[i]);
      }
    }
		if (printed == false) {
			TopOutput("none");
		}
    TopOutput("\n");

    printed = false;

    for (Item item : Items) {
      if (item.isIn(Location)) {
        if (printed == false) {
					if (UseYou == true) {
						TopOutput("\nYou can also see: ");
					} else {
						TopOutput("\nI can also see: ");
					}
          printed = true;
        } else if (Trash80 == false) {
					TopOutput(" - ");
				}

        TopOutput(item.getName());

				if (Trash80 == true) {
					TopOutput(". ");
				}
      }
    }
    TopDone();
  }

  /*
   *	Action Execution Engine
   */

  void ExecuteAction(int val)  /* Called post /150 */ {
    int p;
    int p1;
    int t;
    int ts;

    /*  		System.out.print("A"+(int)val+" P"+(int)Params[ParamPtr]+" "); */
    switch (val) {
      case 0:
        return;
      case 52:
				if (atCarryLimit()) {
					CarryLimit();
				} else {
					Plonk(Param(), Item.Carried);
				}
        return;
      case 53:
        Plonk(Param(), Location);
        return;
      case 54:
        Location = Param();
        Redraw = true;
        return;
      case 55:
        Plonk(Param(), Item.Destroyed);
        return;
      case 56:
        Flags[DarkFlag] = true;
        return;
      case 57:
        Flags[DarkFlag] = false;
        return;
      case 58:
        Flags[Param()] = true;
        return;
      case 59:
        Plonk(Param(), Item.Destroyed);
        return;
      case 60:
        Flags[Param()] = false;
        return;
      case 61:
				if (UseYou) {
					Output("You are dead.\n");
				} else {
					Output("I am dead.\n");
				}
        Flags[DarkFlag] = false;
        Location = (mStaticData.getRooms().length - 1);
        Look();
        return;
      case 62:
        p = Param();
        Items[p].setLocation(Param());
        return;
      case 63:
        /* Do we want a game over exception ? */
        GameOver();
        return;
      case 64:
        Look();
        return;
      case 65:
        ts = CountTreasure();
				if (UseYou) {
					Output("You have stored ");
				} else {
					Output("I've stored ");
				}
        OutputNumber(ts);
        Output(" treasures. On a scale of 0 to 100, that rates ");
        OutputNumber((ts * 100) / mStaticData.getNumTreasures());
        Output(".\n");
        if (ts == mStaticData.getNumTreasures()) {
          Output("Well done.\n");
          GameOver();
        }
        return;
      case 66:
        Inventory();
        return;
      case 67:
        Flags[0] = true;
        return;
      case 68:
        Flags[0] = false;
        return;
      case 69:
        LightTime = mStaticData.getLightRefill();
        Plonk(Lamp, Item.Carried);
        Flags[9] = false;
        return;
      case 70:
        ClearScreen();
        return;
      case 71:
        SaveGame();
        return;
      case 72:
        p = Param();
        p1 = Param();

        t = Items[p].getLocation();
        Plonk(p, Items[p1].getLocation());
        Plonk(p1, t);
        return;
      case 73:
        Continuation = true;
        return;
      case 74:
        Plonk(Param(), Item.Carried);
        return;
      case 75:
        p = Param();
        Plonk(p, Items[Param()].getLocation());
        return;
      case 76:
        Look();
        return;
      case 77:
				if (CurCounter > 0) {
					CurCounter--;
				}
        return;
      case 78:
        OutputNumber(CurCounter);
        return;
      case 79:
        CurCounter = Param();
        return;
      case 80:
        t = Yoho[CurYoho];
        Yoho[CurYoho] = Location;
        Location = t;
        return;
      case 81:
        p = Param();
        ts = CurCounter;
        CurCounter = Counters[p];
        Counters[p] = ts;
        return;
      case 82:
        CurCounter += Param();
        return;
      case 83:
        CurCounter -= Param();
				if (CurCounter < -1) {
					CurCounter = -1;
				}
        return;
      case 84:
        Output(NounString);
        return;
      case 85:
        Output(NounString);
      case 86:
        Output("\n");
        return;
      case 87:
        p = Param();
        t = Location;
        Location = Yoho[p];
        Yoho[p] = t;
        Redraw = true;
        return;
      case 88:
        TwoSecondDelay();
        return;
      case 89:
        DrawPicture(Param());
        return;
      default:
				if (val < 51) {
					Output(mStaticData.getMessages()[val]);
				} else if (val > 101) {
					Output(mStaticData.getMessages()[val - 50]);
				}
        Output(" ");
        return;
    }
  }

  void ExecuteActionPair(int val) {
    ExecuteAction(val / 150);
		if (Ended == false) {
			ExecuteAction(val % 150);
		}
  }

  boolean ExecuteLineCodes(int offset) {
    ParamPtr = 0;
    for (int i = 0; i < 5; i++) {
			if (ExecuteCondition(GameCode(offset)) == false) {
				return false;
			}
      offset++;
    }
    ParamPtr = 0;
    ExecuteActionPair(GameCode(offset));
		if (Ended == false) {
			ExecuteActionPair(GameCode(offset + 1));
		}
    return true;
  }

  boolean RandomChance(int percent) {
    int val = Rng.nextInt() % 100;
		if (val < 0) {
			val = -val;
		}
		if (val >= (int) percent) {
			return false;
		}
    return true;
  }

  /*
   *	Code for executing the tables
   */

  int ExecuteActions(int verb, int noun) {
    int offset = 0;
    boolean found = false;
    boolean completed = false;
    int no, vb;

    Continuation = false;

    for (int i = 0; i < mStaticData.numActions(); i++) {
      vb = GameCode(offset);
      no = (vb % 150);
      vb = (vb / 150);

      if (Continuation == true) {
        /* End of continuation block */
        if (vb != AnyWord || no != AnyWord) {
          Continuation = false;
					if (verb != AnyWord) {
						break;
					}
        }
      }
      /* Check for end of non-automatics */
      if (Continuation == false) {
        /* One execution only */
				if (verb != AnyWord && completed == true) {
					break;
				}
        /* Does not match */
        if (verb != vb) {
          offset = offset + 8;
          continue;
        }
        /* Running automatics - have chance values */
        if (vb == AnyWord) {
          if (RandomChance(no) == false) {
            offset = offset + 8;
            continue;
          }
        } else {
          if (no != noun && no != AnyWord) {
            offset = offset + 8;
            continue;
          }
        }
      }
      found = true;
      /*			System.out.print("V"+(int)vb+"N"+(int)no+":"); */
			if (ExecuteLineCodes(offset + 1) == true) {
				completed = true;
			}
      /*			System.out.println(""); */
      offset = offset + 8;
    }
		if (completed == true) {
			return 0;
		}
		if (found == true) {
			return 1;
		}
    return 2;
  }

  /*
   *	Handle movement automatics
   */

  boolean GoHelper(int noun) {
    int moveto;
    boolean dark = Dark();

    if (noun == NoWord) {
      Output("Give me a direction too.");
      return false;
    }
		if (noun < DirNorth || noun > DirDown) {
			return false;
		}

		if (dark) {
			Output("Dangerous to move in the dark! ");
		}

    moveto = getRoom(Location).getExit(noun - DirNorth);

    if (moveto != 0) {
      Location = moveto;
      Look();
      return true;
    }

    if (dark == false) {
			if (UseYou == false) {
				Output("I can't go in that direction. ");
			} else {
				Output("You can't go in that direction. ");
			}
      return true;
    }

		if (UseYou == false) {
			Output("I fell down and broke my neck. ");
		} else {
			Output("You fell down and broke your neck. ");
		}
    Ended = true;
    return true;
  }

  /*
   *	Find the verb and noun
   */

  /* Match for Brian Howarth 'quickie' extensions - FIXME "I" */
  void MatchQuick(String s) {
    for (int i = 0; i < Quickies.length; i++) {
      if (Globals.StringEqual(s, Quickies[i])) {
        VerbCode = VerbGo;
        NounCode = (i + 1);
        NounString = ExitNames[i];
        break;
      }
    }
  }

  /*
   *	Automatic get/drop functions.
   */

  int MatchUpItem(int no, int where) {
    for (int i = 0; i < Items.length; i++) {
			if (Items[i].isIn(where) && Items[i].getNounCode() == no) {
				return i;
			}
    }
    return NoWord;
  }

  void GetAllHelper() {
    boolean found = false;
    for (int i = 0; i < Items.length; i++) {
      if (Items[i].isIn(Location) && Items[i].getNounCode() != NoWord) {
        ExecuteActions(VerbGet, Items[i].getNounCode());
        if (atCarryLimit()) {
          CarryLimit();
          found = true;
          break;
        }
        Plonk(i, Item.Carried);
        Output(Items[i].getName());
        Output(": OK.\n");
        found = true;
      }
    }
		if (found == false) {
			Output("Nothing taken.\n");
		}
  }

  boolean GetHelper(int no) {
    int what;

    if (Globals.StringEqual(NounString, "ALL")) {
			if (Dark()) {
				Output("It is dark.\n");
			} else {
				GetAllHelper();
			}
      return true;
    }
    if (no == NoWord) {
      Output("What ? ");
      return false;
    }
    if (atCarryLimit()) {
      CarryLimit();
      return false;
    }
    what = MatchUpItem(no, Location);
    if (what == NoWord) {
			if (UseYou) {
				Output("It is beyond your power to do that. ");
			} else {
				Output("It is beyond my power to do that. ");
			}
      return false;
    }
    Plonk(what, Item.Carried);
    Output("O.K. ");
    return true;
  }

  void DropAllHelper() {
    boolean found = false;
    for (int i = 0; i < Items.length; i++) {
      if (Items[i].isInInventory() && Items[i].getNounCode() != NoWord) {
        ExecuteActions(VerbDrop, Items[i].getNounCode());
        Plonk(i, Location);
        Output(Items[i].getName());
        Output(": OK.\n");
        found = true;
      }
    }
		if (found == false) {
			Output("Nothing dropped.\n");
		}
  }

  boolean DropHelper(int no) {
    int what;

    if (Globals.StringEqual(NounString, "ALL")) {
      DropAllHelper();
      return true;
    }
    if (no == NoWord) {
      Output("What ? ");
      return false;
    }
    what = MatchUpItem(no, Location);
    if (what == NoWord) {
			if (UseYou) {
				Output("It is beyond your power to do that. ");
			} else {
				Output("It is beyond my power to do that. ");
			}
      return false;
    }
    Plonk(what, Location);
    Output("O.K. ");
    return true;
  }

  /*
   *	Given a parsed input perform the command
   */

  boolean RunCommandLine(int vb, int no) {
    int state;

    if (vb == VerbGo) {
			if (GoHelper(no)) {
				return true;
			}
    }
    state = ExecuteActions(vb, no);
    if (state != 0) {
      if (vb == VerbGet) {
				if (GetHelper(no) == true) {
					return true;
				}
      } else if (vb == VerbDrop) {
				if (DropHelper(no) == true) {
					return true;
				}
      } else {
				if (state == 2) {
					Output("I don't understand your command. ");
				}
				if (state == 1) {
					Output("I can't do that yet. ");
				}
      }
      return false;
    }
    return true;
  }

  /*
   *	Emulate the hard coded lamp functionality
   */

  void LampIterate() {
		if (Items[Lamp].isDestroyed()) {
			return;
		}
		if (LightTime == -1) {
			return;
		}
    LightTime--;
    if (LightTime < 1) {
      Flags[LightOutFlag] = true;
      if (Items[Lamp].isInInventory() ||
          Items[Lamp].isIn(Location)) {
				if (ScottLight) {
					Output("Light has run out! ");
				} else if (UseYou) {
					Output("Your light has run out. ");
				} else {
					Output("My light has run out. ");
				}
				if (Flags[DarkFlag] == true) {
					Redraw = true;
				}
      }
			if (OldLamp) {
				Plonk(Lamp, Item.Destroyed);
			}
    } else if (LightTime < 25) {
      if (Items[Lamp].isInInventory() || Items[Lamp].isIn(Location)) {
        if (ScottLight) {
          Output("Light runs out in ");
          OutputNumber(LightTime);
          Output(" turns. ");
        } else if ((LightTime % 5) == 0) {
					if (UseYou) {
						Output("Your light is growing dim. ");
					} else {
						Output("My light is growing dim. ");
					}
        }
      }
    }
  }

  /*
   *	Run the first iteration of the game processing
   */

  public void FirstGameCycle() {
    ExecuteActions(AnyWord, AnyWord);
    Look();
    Redraw = false;
  }

  public boolean ParseInput(String input) {
		/* We want this but it isn't in the MIDP profile
		String[] words = input.split(" "); */
    String VerbString;
    int pos;
    int words;

    VerbCode = NoWord;
    NounCode = NoWord;

    input = input.trim();
		if (input.equals("")) {
			return false;
		}

    NounString = "";

    pos = input.indexOf(' ');
    if (pos == -1) {
      VerbString = input;
      words = 1;
    } else {
      VerbString = input.substring(0, pos);
      input = input.substring(pos + 1).trim();
      pos = input.indexOf(' ');
			if (pos == -1) {
				NounString = input;
			} else {
				NounString = input.substring(pos - 1);
			}
      words = 2;
    }

    VerbCode = mStaticData.MatchVerb(VerbString);
    if (words > 1) {
      NounCode = mStaticData.MatchNoun(NounString);
    }
    if (words == 1 && VerbCode == AnyWord) {
      int alt = mStaticData.MatchNoun(VerbString);
      if (alt >= DirNorth && alt <= DirDown) {
        VerbCode = VerbGo;
        NounCode = alt;
        NounString = VerbString;
      } else {
        MatchQuick(VerbString);
      }
    }

    if (VerbCode == AnyWord) {
      Output("You use word(s) I don't know! ");
      return false;
    }
    return true;
  }

  /*
   *	Run further iterations
   */

  public boolean GameCycle(String input) {
    mDrawingAgent.outputBottom("\n>" + input + '\n');
		if (ParseInput(input) == false) {
			return true;
		}
    RunCommandLine(VerbCode, NounCode);
    if (Ended == false) {
      LampIterate();
      ExecuteActions(AnyWord, AnyWord);
    }
    if (Redraw == true) {
      Look();
      Redraw = false;
    }
    return !Ended;
  }
}
